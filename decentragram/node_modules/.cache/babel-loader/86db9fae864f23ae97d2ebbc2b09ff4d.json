{"ast":null,"code":"/**\r\n * Javascript implementation of PKCS#12.\r\n *\r\n * @author Dave Longley\r\n * @author Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * The ASN.1 representation of PKCS#12 is as follows\r\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r\n *\r\n * PFX ::= SEQUENCE {\r\n *   version  INTEGER {v3(3)}(v3,...),\r\n *   authSafe ContentInfo,\r\n *   macData  MacData OPTIONAL\r\n * }\r\n *\r\n * MacData ::= SEQUENCE {\r\n *   mac DigestInfo,\r\n *   macSalt OCTET STRING,\r\n *   iterations INTEGER DEFAULT 1\r\n * }\r\n * Note: The iterations default is for historical reasons and its use is\r\n * deprecated. A higher value, like 1024, is recommended.\r\n *\r\n * DigestInfo is defined in PKCS#7 as follows:\r\n *\r\n * DigestInfo ::= SEQUENCE {\r\n *   digestAlgorithm DigestAlgorithmIdentifier,\r\n *   digest Digest\r\n * }\r\n *\r\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r\n *\r\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r\n * for the algorithm, if any. In the case of SHA1 there is none.\r\n *\r\n * AlgorithmIdentifer ::= SEQUENCE {\r\n *    algorithm OBJECT IDENTIFIER,\r\n *    parameters ANY DEFINED BY algorithm OPTIONAL\r\n * }\r\n *\r\n * Digest ::= OCTET STRING\r\n *\r\n *\r\n * ContentInfo ::= SEQUENCE {\r\n *   contentType ContentType,\r\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r\n * }\r\n *\r\n * ContentType ::= OBJECT IDENTIFIER\r\n *\r\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n * -- Data if unencrypted\r\n * -- EncryptedData if password-encrypted\r\n * -- EnvelopedData if public key-encrypted\r\n *\r\n *\r\n * SafeContents ::= SEQUENCE OF SafeBag\r\n *\r\n * SafeBag ::= SEQUENCE {\r\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n * }\r\n *\r\n * PKCS12Attribute ::= SEQUENCE {\r\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r\n * } -- This type is compatible with the X.500 type 'Attribute'\r\n *\r\n * PKCS12AttrSet ATTRIBUTE ::= {\r\n *   friendlyName | -- from PKCS #9\r\n *   localKeyId, -- from PKCS #9\r\n *   ... -- Other attributes are allowed\r\n * }\r\n *\r\n * CertBag ::= SEQUENCE {\r\n *   certId    BAG-TYPE.&id   ({CertTypes}),\r\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n * }\r\n *\r\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\r\n *\r\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r\n * -- Base64-encoded SDSI certificate stored in IA5String\r\n *\r\n * CertTypes BAG-TYPE ::= {\r\n *   x509Certificate |\r\n *   sdsiCertificate,\r\n *   ... -- For future extensions\r\n * }\r\n */\nvar forge = require('./forge');\n\nrequire('./asn1');\n\nrequire('./hmac');\n\nrequire('./oids');\n\nrequire('./pkcs7asn1');\n\nrequire('./pbe');\n\nrequire('./random');\n\nrequire('./rsa');\n\nrequire('./sha1');\n\nrequire('./util');\n\nrequire('./x509'); // shortcut for asn.1 & PKI API\n\n\nvar asn1 = forge.asn1;\nvar pki = forge.pki; // shortcut for PKCS#12 API\n\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n\n    /* So far we only support X.509 certificates (which are wrapped in\r\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n/**\r\n * Search SafeContents structure for bags with matching attributes.\r\n *\r\n * The search can optionally be narrowed by a certain bag type.\r\n *\r\n * @param safeContents the SafeContents structure to search in.\r\n * @param attrName the name of the attribute to compare against.\r\n * @param attrValue the attribute value to search for.\r\n * @param [bagType] bag type to narrow search by.\r\n *\r\n * @return an array of matching bags.\r\n */\n\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for (var i = 0; i < safeContents.length; i++) {\n    for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n\n      if (bagType !== undefined && bag.type !== bagType) {\n        continue;\n      } // only filter by bag type, no attribute specified\n\n\n      if (attrName === null) {\n        result.push(bag);\n        continue;\n      }\n\n      if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r\n *\r\n * @param obj The PKCS#12 PFX in ASN.1 notation.\r\n * @param strict true to use strict DER decoding, false not to (default: true).\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return PKCS#12 PFX object.\r\n */\n\n\np12.pkcs12FromAsn1 = function (obj, strict, password) {\n  // handle args\n  if (typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if (strict === undefined) {\n    strict = true;\n  } // validate PFX and capture data\n\n\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\r\n     * Gets bags with matching attributes.\r\n     *\r\n     * @param filter the attributes to filter by:\r\n     *          [localKeyId] the localKeyId to search for.\r\n     *          [localKeyIdHex] the localKeyId in hex to search for.\r\n     *          [friendlyName] the friendly name to search for.\r\n     *          [bagType] bag type to narrow each attribute search by.\r\n     *\r\n     * @return a map of attribute type to an array of matching bags or, if no\r\n     *           attribute was given but a bag type, the map key will be the\r\n     *           bag type.\r\n     */\n    getBags: function getBags(filter) {\n      var rval = {};\n      var localKeyId;\n\n      if ('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if ('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      } // filter on bagType only\n\n\n      if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if (localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);\n      }\n\n      if ('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching friendlyName attribute.\r\n     *\r\n     * @param friendlyName the friendly name to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching friendlyName attribute.\r\n     */\n    getBagsByFriendlyName: function getBagsByFriendlyName(friendlyName, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching localKeyId attribute.\r\n     *\r\n     * @param localKeyId the localKeyId to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching localKeyId attribute.\r\n     */\n    getBagsByLocalKeyId: function getBagsByLocalKeyId(localKeyId, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if (capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n\n  if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n\n  data = _decodePkcs7Data(data); // check for MAC\n\n  if (capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n\n    switch (macAlgorithm) {\n      case pki.oids.sha1:\n        md = forge.md.sha1.create();\n        macKeyBytes = 20;\n        break;\n\n      case pki.oids.sha256:\n        md = forge.md.sha256.create();\n        macKeyBytes = 32;\n        break;\n\n      case pki.oids.sha384:\n        md = forge.md.sha384.create();\n        macKeyBytes = 48;\n        break;\n\n      case pki.oids.sha512:\n        md = forge.md.sha512.create();\n        macKeyBytes = 64;\n        break;\n\n      case pki.oids.md5:\n        md = forge.md.md5.create();\n        macKeyBytes = 16;\n        break;\n    }\n\n    if (md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    } // verify MAC (iterations default to 1)\n\n\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = 'macIterations' in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n    var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n\n    if (macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n\n  return pfx;\n};\n/**\r\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r\n * function transforms this corner-case into the usual simple,\r\n * non-composed/constructed OCTET STRING.\r\n *\r\n * This function may be moved to ASN.1 at some point to better deal with\r\n * more BER-encoding issues, should they arise.\r\n *\r\n * @param data the ASN.1 Data object to transform.\r\n */\n\n\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if (data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n\n    for (var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n\n  return data;\n}\n/**\r\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r\n *\r\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r\n *\r\n * @param pfx The PKCS#12 PFX object to fill.\r\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n */\n\n\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);\n  /* actually it's BER encoded */\n\n  if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');\n  }\n\n  for (var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i]; // validate contentInfo and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n\n    switch (asn1.derToOid(capture.contentType)) {\n      case pki.oids.data:\n        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n          throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n        }\n\n        safeContents = _decodePkcs7Data(data).value;\n        break;\n\n      case pki.oids.encryptedData:\n        safeContents = _decryptSafeContents(data, password);\n        obj.encrypted = true;\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 contentType.');\n        error.contentType = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n/**\r\n * Decrypt PKCS#7 EncryptedData structure.\r\n *\r\n * @param data ASN.1 encoded EncryptedContentInfo object.\r\n * @param password The user-provided password.\r\n *\r\n * @return The decrypted SafeContents (ASN.1 object).\r\n */\n\n\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n\n  if (oid !== pki.oids.data) {\n    var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  } // get cipher\n\n\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password); // get encrypted data\n\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n  cipher.update(encrypted);\n\n  if (!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n/**\r\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r\n *\r\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r\n *\r\n * @param {String} safeContents BER-encoded safeContents.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return {Array} Array of Bag objects.\r\n */\n\n\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if (!strict && safeContents.length === 0) {\n    return [];\n  } // actually it's BER-encoded\n\n\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n    throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n\n  for (var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i]; // validate SafeBag and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n    /* Create bag object and push to result array. */\n\n\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n\n    switch (bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r\n           Afterwards we can handle it like a keyBag,\r\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n\n        if (bagAsn1 === null) {\n          throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n      /* fall through */\n\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r\n           PKI module, hence we don't have to do validation/capturing here,\r\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch (e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n\n        continue;\n\n      /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r\n           Therefore put the SafeBag content through another validator to\r\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n\n        decoder = function decoder() {\n          if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error('Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          } // true=produce cert hash\n\n\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch (e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n\n\n    if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n    /* Call decoder function from above to store the results. */\n\n\n    decoder();\n  }\n\n  return res;\n}\n/**\r\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r\n *\r\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r\n *\r\n * @return the decoded attributes.\r\n */\n\n\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if (attributes !== undefined) {\n    for (var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n\n      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n\n      if (pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n\n      for (var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n/**\r\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r\n * password is provided then the private key will be encrypted.\r\n *\r\n * An entire certificate chain may also be included. To do this, pass\r\n * an array for the \"cert\" parameter where the first certificate is\r\n * the one that is paired with the private key and each subsequent one\r\n * verifies the previous one. The certificates may be in PEM format or\r\n * have been already parsed by Forge.\r\n *\r\n * @todo implement password-based-encryption for the whole package\r\n *\r\n * @param key the private key.\r\n * @param cert the certificate (may be an array of certificates in order\r\n *          to specify a certificate chain).\r\n * @param password the password to use, null for none.\r\n * @param options:\r\n *          algorithm the encryption algorithm to use\r\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r\n *          count the iteration count to use.\r\n *          saltSize the salt size to use.\r\n *          useMac true to include a MAC, false not to, defaults to true.\r\n *          localKeyId the local key ID to use, in hex.\r\n *          friendlyName the friendly name to use.\r\n *          generateLocalKeyId true to generate a random local key ID,\r\n *            false not to, defaults to true.\r\n *\r\n * @return the PKCS#12 PFX ASN.1 object.\r\n */\n\n\np12.toPkcs12Asn1 = function (key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n\n  if (!('useMac' in options)) {\n    options.useMac = true;\n  }\n\n  if (!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n\n  if (!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n\n  if (localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if (options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if (cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n\n      if (typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n\n  if (localKeyId !== null) {\n    attrs.push( // localKeyID\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));\n  }\n\n  if ('friendlyName' in options) {\n    attrs.push( // friendlyName\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));\n  }\n\n  if (attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  } // collect contents for AuthenticatedSafe\n\n\n  var contents = []; // create safe bag(s) for certificate chain\n\n  var chain = [];\n\n  if (cert !== null) {\n    if (forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n\n  for (var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n\n    if (typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    } // SafeBag\n\n\n    var certBagAttrs = i === 0 ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), // bagValue\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// CertBag\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// certId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), // certValue (x509Certificate)\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), // bagAttributes (OPTIONAL)\n    certBagAttrs]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if (certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags); // ContentInfo\n\n    var certCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);\n    contents.push(certCI);\n  } // create safe contents for private key\n\n\n  var keyBag = null;\n\n  if (key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n\n    if (password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// PrivateKeyInfo\n      pkAsn1]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// EncryptedPrivateKeyInfo\n      pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } // SafeContents\n\n\n    var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]); // ContentInfo\n\n    var keyCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);\n    contents.push(keyCI);\n  } // create AuthenticatedSafe by stringing together the contents\n\n\n  var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n  var macData;\n\n  if (options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n    var count = options.count; // 160-bit key\n\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// mac DigestInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm = SHA-1\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), // parameters = Null\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // digest\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), // macSalt OCTET STRING\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), // iterations INTEGER (XXX: Only support count < 65536)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);\n  } // PFX\n\n\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version (3)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), // PKCS#7 ContentInfo\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n  asn1.oidToDer(pki.oids.data).getBytes()), // content\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);\n};\n/**\r\n * Derives a PKCS#12 key.\r\n *\r\n * @param password the password to derive the key material from, null or\r\n *          undefined for none.\r\n * @param salt the salt, as a ByteBuffer, to use.\r\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r\n * @param iter the iteration count.\r\n * @param n the number of bytes to derive from the password.\r\n * @param md the message digest to use, defaults to SHA-1.\r\n *\r\n * @return a ByteBuffer with the bytes derived from the password.\r\n */\n\n\np12.generateKey = forge.pbe.generatePkcs12Key;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar codec = require('./codec');\n\nvar protocols = require('./protocols-table');\n\nvar varint = require('varint');\n\nvar bs58 = require('bs58');\n\nvar withIs = require('class-is');\n/**\r\n * Creates a [multiaddr](https://github.com/multiformats/multiaddr) from\r\n * a Buffer, String or another Multiaddr instance\r\n * public key.\r\n * @class Multiaddr\r\n * @param {(String|Buffer|Multiaddr)} addr - If String or Buffer, needs to adhere\r\n * to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\n\nvar Multiaddr = withIs.proto(function (addr) {\n  if (!(this instanceof Multiaddr)) {\n    return new Multiaddr(addr);\n  } // default\n\n\n  if (addr == null) {\n    addr = '';\n  }\n\n  if (addr instanceof Buffer) {\n    /**\r\n     * @type {Buffer} - The raw bytes representing this multiaddress\r\n     */\n    this.buffer = codec.fromBuffer(addr);\n  } else if (typeof addr === 'string' || addr instanceof String) {\n    if (addr.length > 0 && addr.charAt(0) !== '/') {\n      throw new Error(\"multiaddr \\\"\".concat(addr, \"\\\" must start with a \\\"/\\\"\"));\n    }\n\n    this.buffer = codec.fromString(addr);\n  } else if (addr.buffer && addr.protos && addr.protoCodes) {\n    // Multiaddr\n    this.buffer = codec.fromBuffer(addr.buffer); // validate + copy buffer\n  } else {\n    throw new Error('addr must be a string, Buffer, or another Multiaddr');\n  }\n}, {\n  className: 'Multiaddr',\n  symbolName: '@multiformats/js-multiaddr/multiaddr'\n});\n/**\r\n * Returns Multiaddr as a String\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\n\nMultiaddr.prototype.toString = function toString() {\n  return codec.bufferToString(this.buffer);\n};\n/**\r\n * Returns Multiaddr as a JSON encoded object\r\n *\r\n * @returns {String}\r\n * @example\r\n * JSON.stringify(Multiaddr('/ip4/127.0.0.1/tcp/4001'))\r\n * // '/ip4/127.0.0.1/tcp/4001'\r\n */\n\n\nMultiaddr.prototype.toJSON = Multiaddr.prototype.toString;\n/**\r\n * Returns Multiaddr as a convinient options object to be used with net.createConnection\r\n *\r\n * @returns {{family: String, host: String, transport: String, port: String}}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\r\n * // { family: 'ipv4', host: '127.0.0.1', transport: 'tcp', port: '4001' }\r\n */\n\nMultiaddr.prototype.toOptions = function toOptions() {\n  var opts = {};\n  var parsed = this.toString().split('/');\n  opts.family = parsed[1] === 'ip4' ? 'ipv4' : 'ipv6';\n  opts.host = parsed[2];\n  opts.transport = parsed[3];\n  opts.port = parsed[4];\n  return opts;\n};\n/**\r\n * Returns Multiaddr as a human-readable string\r\n *\r\n * @returns {String}\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').inspect()\r\n * // '<Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>'\r\n */\n\n\nMultiaddr.prototype.inspect = function inspect() {\n  return '<Multiaddr ' + this.buffer.toString('hex') + ' - ' + codec.bufferToString(this.buffer) + '>';\n};\n/**\r\n * Returns the protocols the Multiaddr is defined with, as an array of objects, in\r\n * left-to-right order. Each object contains the protocol code, protocol name,\r\n * and the size of its address space in bits.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Object>} protocols - All the protocols the address is composed of\r\n * @returns {Number} protocols[].code\r\n * @returns {Number} protocols[].size\r\n * @returns {String} protocols[].name\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\r\n * // [ { code: 4, size: 32, name: 'ip4' },\r\n * //   { code: 6, size: 16, name: 'tcp' } ]\r\n */\n\n\nMultiaddr.prototype.protos = function protos() {\n  return this.protoCodes().map(function (code) {\n    return Object.assign({}, protocols(code));\n  });\n};\n/**\r\n * Returns the codes of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @returns {Array.<Number>} protocol codes\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\r\n * // [ 4, 6 ]\r\n */\n\n\nMultiaddr.prototype.protoCodes = function protoCodes() {\n  var codes = [];\n  var buf = this.buffer;\n  var i = 0;\n\n  while (i < buf.length) {\n    var code = varint.decode(buf, i);\n    var n = varint.decode.bytes;\n    var p = protocols(code);\n    var size = codec.sizeForAddr(p, buf.slice(i + n));\n    i += size + n;\n    codes.push(code);\n  }\n\n  return codes;\n};\n/**\r\n * Returns the names of the protocols in left-to-right order.\r\n * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\r\n *\r\n * @return {Array.<String>} protocol names\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\r\n * // [ 'ip4', 'tcp' ]\r\n */\n\n\nMultiaddr.prototype.protoNames = function protoNames() {\n  return this.protos().map(function (proto) {\n    return proto.name;\n  });\n};\n/**\r\n * Returns a tuple of parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {Buffer} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").tuples()\r\n * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\r\n */\n\n\nMultiaddr.prototype.tuples = function tuples() {\n  return codec.bufferToTuples(this.buffer);\n};\n/**\r\n * Returns a tuple of string/number parts\r\n *\r\n * @return {Array.<Array>} tuples\r\n * @return {Number} tuples[].0 code of protocol\r\n * @return {(String|Number)} tuples[].1 contents of address\r\n * @example\r\n * Multiaddr(\"/ip4/127.0.0.1/tcp/4001\").stringTuples()\r\n * // [ [ 4, '127.0.0.1' ], [ 6, 4001 ] ]\r\n */\n\n\nMultiaddr.prototype.stringTuples = function stringTuples() {\n  var t = codec.bufferToTuples(this.buffer);\n  return codec.tuplesToStringTuples(t);\n};\n/**\r\n * Encapsulates a Multiaddr in another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to add into this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.toString()\r\n * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\r\n */\n\n\nMultiaddr.prototype.encapsulate = function encapsulate(addr) {\n  addr = Multiaddr(addr);\n  return Multiaddr(this.toString() + addr.toString());\n};\n/**\r\n * Decapsulates a Multiaddr from another Multiaddr\r\n *\r\n * @param {Multiaddr} addr - Multiaddr to remove from this Multiaddr\r\n * @return {Multiaddr}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 0408080808060438047f000001060fa1 - /ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh3.decapsulate(mh2).toString()\r\n * // '/ip4/8.8.8.8/tcp/1080'\r\n */\n\n\nMultiaddr.prototype.decapsulate = function decapsulate(addr) {\n  addr = addr.toString();\n  var s = this.toString();\n  var i = s.lastIndexOf(addr);\n\n  if (i < 0) {\n    throw new Error('Address ' + this + ' does not contain subaddress: ' + addr);\n  }\n\n  return Multiaddr(s.slice(0, i));\n};\n/**\r\n * Extract the peerId if the multiaddr contains one\r\n *\r\n * @return {String|null} peerId - The id of the peer or null if invalid or missing from the ma\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string>\r\n *\r\n * // should return QmValidBase58string or null if the id is missing or invalid\r\n * const peerId = mh1.getPeerId()\r\n */\n\n\nMultiaddr.prototype.getPeerId = function getPeerId() {\n  var b58str = null;\n\n  try {\n    var tuples = this.stringTuples().filter(function (tuple) {\n      if (tuple[0] === protocols.names.ipfs.code) {\n        return true;\n      }\n    }); // Get the last id\n\n    b58str = tuples.pop()[1];\n    bs58.decode(b58str);\n  } catch (e) {\n    b58str = null;\n  }\n\n  return b58str;\n};\n/**\r\n * Extract the path if the multiaddr contains one\r\n *\r\n * @return {String|null} path - The path of the multiaddr, or null if no path protocol is present\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock>\r\n *\r\n * // should return utf8 string or null if the id is missing or invalid\r\n * const path = mh1.getPath()\r\n */\n\n\nMultiaddr.prototype.getPath = function getPath() {\n  var path = null;\n\n  try {\n    path = this.stringTuples().filter(function (tuple) {\n      var proto = protocols(tuple[0]);\n\n      if (proto.path) {\n        return true;\n      }\n    })[0][1];\n  } catch (e) {\n    path = null;\n  }\n\n  return path;\n};\n/**\r\n * Checks if two Multiaddrs are the same\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool}\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/8.8.8.8/tcp/1080')\r\n * // <Multiaddr 0408080808060438 - /ip4/8.8.8.8/tcp/1080>\r\n *\r\n * const mh2 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n *\r\n * mh1.equals(mh1)\r\n * // true\r\n *\r\n * mh1.equals(mh2)\r\n * // false\r\n */\n\n\nMultiaddr.prototype.equals = function equals(addr) {\n  return this.buffer.equals(addr.buffer);\n};\n/**\r\n * Gets a Multiaddrs node-friendly address object. Note that protocol information\r\n * is left out: in Node (and most network systems) the protocol is unknowable\r\n * given only the address.\r\n *\r\n * Has to be a ThinWaist Address, otherwise throws error\r\n *\r\n * @returns {{family: String, address: String, port: String}}\r\n * @throws {Error} Throws error if Multiaddr is not a Thin Waist address\r\n * @example\r\n * Multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\r\n * // {family: 'IPv4', address: '127.0.0.1', port: '4001'}\r\n */\n\n\nMultiaddr.prototype.nodeAddress = function nodeAddress() {\n  var codes = this.protoCodes();\n  var names = this.protoNames();\n  var parts = this.toString().split('/').slice(1);\n\n  if (parts.length < 4) {\n    throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}\".');\n  } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[0], \"'\\\". Must have a valid family name: \\\"{ip4, ip6, dns4, dns6}\\\".\"));\n  } else if (parts[2] !== 'tcp' && parts[2] !== 'udp') {\n    throw new Error(\"no protocol with name: \\\"'\".concat(names[1], \"'\\\". Must have a valid transport protocol: \\\"{tcp, udp}\\\".\"));\n  }\n\n  return {\n    family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,\n    address: parts[1],\n    // ip addr\n    port: parts[3] // tcp or udp port\n\n  };\n};\n/**\r\n * Creates a Multiaddr from a node-friendly address object\r\n *\r\n * @param {String} addr\r\n * @param {String} transport\r\n * @returns {Multiaddr} multiaddr\r\n * @throws {Error} Throws error if addr is not truthy\r\n * @throws {Error} Throws error if transport is not truthy\r\n * @example\r\n * Multiaddr.fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n */\n\n\nMultiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {\n  if (!addr) throw new Error('requires node address object');\n  if (!transport) throw new Error('requires transport protocol');\n  var ip = addr.family === 'IPv6' ? 'ip6' : 'ip4';\n  return Multiaddr('/' + [ip, addr.address, transport, addr.port].join('/'));\n}; // TODO find a better example, not sure about it's good enough\n\n/**\r\n * Returns if a Multiaddr is a Thin Waist address or not.\r\n *\r\n * Thin Waist is if a Multiaddr adheres to the standard combination of:\r\n *\r\n * `{IPv4, IPv6}/{TCP, UDP}`\r\n *\r\n * @param {Multiaddr} [addr] - Defaults to using `this` instance\r\n * @returns {Boolean} isThinWaistAddress\r\n * @example\r\n * const mh1 = Multiaddr('/ip4/127.0.0.1/tcp/4001')\r\n * // <Multiaddr 047f000001060fa1 - /ip4/127.0.0.1/tcp/4001>\r\n * const mh2 = Multiaddr('/ip4/192.168.2.1/tcp/5001')\r\n * // <Multiaddr 04c0a80201061389 - /ip4/192.168.2.1/tcp/5001>\r\n * const mh3 = mh1.encapsulate(mh2)\r\n * // <Multiaddr 047f000001060fa104c0a80201061389 - /ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001>\r\n * mh1.isThinWaistAddress()\r\n * // true\r\n * mh2.isThinWaistAddress()\r\n * // true\r\n * mh3.isThinWaistAddress()\r\n * // false\r\n */\n\n\nMultiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {\n  var protos = (addr || this).protos();\n\n  if (protos.length !== 2) {\n    return false;\n  }\n\n  if (protos[0].code !== 4 && protos[0].code !== 41) {\n    return false;\n  }\n\n  if (protos[1].code !== 6 && protos[1].code !== 273) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Object containing table, names and codes of all supported protocols.\r\n * To get the protocol values from a Multiaddr, you can use\r\n * [`.protos()`](#multiaddrprotos),\r\n * [`.protoCodes()`](#multiaddrprotocodes) or\r\n * [`.protoNames()`](#multiaddrprotonames)\r\n *\r\n * @instance\r\n * @returns {{table: Array, names: Object, codes: Object}}\r\n *\r\n */\n\n\nMultiaddr.protocols = protocols;\n/**\r\n * Returns if something is a Multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n * @return {Bool} isName\r\n */\n\nMultiaddr.isName = function isName(addr) {\n  if (!Multiaddr.isMultiaddr(addr)) {\n    return false;\n  } // if a part of the multiaddr is resolvable, then return true\n\n\n  return addr.protos().some(function (proto) {\n    return proto.resolvable;\n  });\n};\n/**\r\n * Returns an array of multiaddrs, by resolving the multiaddr that is a name\r\n *\r\n * @param {Multiaddr} addr\r\n *\r\n * @param {Function} callback\r\n * @return {Bool} isName\r\n */\n\n\nMultiaddr.resolve = function resolve(addr, callback) {\n  if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {\n    return callback(new Error('not a valid name'));\n  }\n  /*\r\n   * Needs more consideration from spec design:\r\n   *   - what to return\r\n   *   - how to achieve it in the browser?\r\n   */\n\n\n  return callback(new Error('not implemented yet'));\n};\n\nexports = module.exports = Multiaddr;","map":null,"metadata":{},"sourceType":"script"}
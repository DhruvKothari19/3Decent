{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = asyncify;\n\nvar _isObject = require('lodash/isObject');\n\nvar _isObject2 = _interopRequireDefault(_isObject);\n\nvar _initialParams = require('./internal/initialParams');\n\nvar _initialParams2 = _interopRequireDefault(_initialParams);\n\nvar _setImmediate = require('./internal/setImmediate');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\r\n * Take a sync function and make it async, passing its return value to a\r\n * callback. This is useful for plugging sync functions into a waterfall,\r\n * series, or other async functions. Any arguments passed to the generated\r\n * function will be passed to the wrapped function (except for the final\r\n * callback argument). Errors thrown will be passed to the callback.\r\n *\r\n * If the function passed to `asyncify` returns a Promise, that promises's\r\n * resolved/rejected state will be used to call the callback, rather than simply\r\n * the synchronous return value.\r\n *\r\n * This also means you can asyncify ES2017 `async` functions.\r\n *\r\n * @name asyncify\r\n * @static\r\n * @memberOf module:Utils\r\n * @method\r\n * @alias wrapSync\r\n * @category Util\r\n * @param {Function} func - The synchronous function, or Promise-returning\r\n * function to convert to an {@link AsyncFunction}.\r\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\r\n * invoked with `(args..., callback)`.\r\n * @example\r\n *\r\n * // passing a regular synchronous function\r\n * async.waterfall([\r\n *     async.apply(fs.readFile, filename, \"utf8\"),\r\n *     async.asyncify(JSON.parse),\r\n *     function (data, next) {\r\n *         // data is the result of parsing the text.\r\n *         // If there was a parsing error, it would have been caught.\r\n *     }\r\n * ], callback);\r\n *\r\n * // passing a function returning a promise\r\n * async.waterfall([\r\n *     async.apply(fs.readFile, filename, \"utf8\"),\r\n *     async.asyncify(function (contents) {\r\n *         return db.model.create(contents);\r\n *     }),\r\n *     function (model, next) {\r\n *         // `model` is the instantiated model object.\r\n *         // If there was an error, this function would be skipped.\r\n *     }\r\n * ], callback);\r\n *\r\n * // es2017 example, though `asyncify` is not needed if your JS environment\r\n * // supports async functions out of the box\r\n * var q = async.queue(async.asyncify(async function(file) {\r\n *     var intermediateStep = await processFile(file);\r\n *     return await somePromise(intermediateStep)\r\n * }));\r\n *\r\n * q.push(files);\r\n */\n\n\nfunction asyncify(func) {\n  return (0, _initialParams2.default)(function (args, callback) {\n    var result;\n\n    try {\n      result = func.apply(this, args);\n    } catch (e) {\n      return callback(e);\n    } // if result is Promise object\n\n\n    if ((0, _isObject2.default)(result) && typeof result.then === 'function') {\n      result.then(function (value) {\n        invokeCallback(callback, null, value);\n      }, function (err) {\n        invokeCallback(callback, err.message ? err : new Error(err));\n      });\n    } else {\n      callback(null, result);\n    }\n  });\n}\n\nfunction invokeCallback(callback, error, value) {\n  try {\n    callback(error, value);\n  } catch (e) {\n    (0, _setImmediate2.default)(rethrow, e);\n  }\n}\n\nfunction rethrow(error) {\n  throw error;\n}\n\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}
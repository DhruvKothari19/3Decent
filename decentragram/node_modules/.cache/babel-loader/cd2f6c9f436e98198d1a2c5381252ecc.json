{"ast":null,"code":"/**\r\n * Cipher base API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nmodule.exports = forge.cipher = forge.cipher || {}; // registered algorithms\n\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n/**\r\n * Creates a cipher object that can be used to encrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\n\nforge.cipher.createCipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n/**\r\n * Creates a decipher object that can be used to decrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.cipher.createDecipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n/**\r\n * Registers an algorithm by name. If the name was already registered, the\r\n * algorithm API object will be overwritten.\r\n *\r\n * @param name the name of the algorithm.\r\n * @param algorithm the algorithm API object.\r\n */\n\n\nforge.cipher.registerAlgorithm = function (name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n/**\r\n * Gets a registered algorithm by name.\r\n *\r\n * @param name the name of the algorithm.\r\n *\r\n * @return the algorithm, if found, null if not.\r\n */\n\n\nforge.cipher.getAlgorithm = function (name) {\n  name = name.toUpperCase();\n\n  if (name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n\n  return null;\n};\n\nvar BlockCipher = forge.cipher.BlockCipher = function (options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n/**\r\n * Starts or restarts the encryption or decryption process, whichever\r\n * was previously configured.\r\n *\r\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r\n * 32-bit integers, then it must be 4 integers long.\r\n *\r\n * Note: an IV is not required or used in ECB mode.\r\n *\r\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r\n * by NIST SP-800-38D but another length may be given.\r\n *\r\n * @param options the options to use:\r\n *          iv the initialization vector to use as a binary-encoded string of\r\n *            bytes, null to reuse the last ciphered block from a previous\r\n *            update() (this \"residue\" method is for legacy support only).\r\n *          additionalData additional authentication data as a binary-encoded\r\n *            string of bytes, for 'GCM' mode, (default: none).\r\n *          tagLength desired length of authentication tag, in bits, for\r\n *            'GCM' mode (0-128, default: 128).\r\n *          tag the authentication tag to check if decrypting, as a\r\n *             binary-encoded string of bytes.\r\n *          output the output the buffer to write to, null to create one.\r\n */\n\n\nBlockCipher.prototype.start = function (options) {\n  options = options || {};\n  var opts = {};\n\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n/**\r\n * Updates the next block according to the cipher mode.\r\n *\r\n * @param input the buffer to read from.\r\n */\n\n\nBlockCipher.prototype.update = function (input) {\n  if (input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  } // do cipher operation until it needs more input and not finished\n\n\n  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {} // free consumed memory from input buffer\n\n\n  this._input.compact();\n};\n/**\r\n * Finishes encrypting or decrypting.\r\n *\r\n * @param pad a padding function to use in CBC mode, null for default,\r\n *          signature(blockSize, buffer, decrypt).\r\n *\r\n * @return true if successful, false on error.\r\n */\n\n\nBlockCipher.prototype.finish = function (pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function (input) {\n      return pad(this.blockSize, input, false);\n    };\n\n    this.mode.unpad = function (output) {\n      return pad(this.blockSize, output, true);\n    };\n  } // build options for padding and afterFinish functions\n\n\n  var options = {};\n  options.decrypt = this._decrypt; // get # of bytes that won't fill a block\n\n  options.overflow = this._input.length() % this.blockSize;\n\n  if (!this._decrypt && this.mode.pad) {\n    if (!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  } // do final update\n\n\n  this._finish = true;\n  this.update();\n\n  if (this._decrypt && this.mode.unpad) {\n    if (!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n\n  if (this.mode.afterFinish) {\n    if (!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}